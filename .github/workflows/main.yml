Adicionar Integração Contínua e Implantação Contínua
Tempo estimado necessário: 60 minutos

Sua equipe está crescendo! A gestão decidiu contratar engenheiros de front-end e back-end para garantir que as funcionalidades no roadmap sejam desenvolvidas a tempo para futuros lançamentos. No entanto, isso significa que vários engenheiros precisarão trabalhar em paralelo no repositório. Você tem a tarefa de garantir que o código enviado para a branch principal atenda ao estilo de codificação da equipe e esteja livre de erros de sintaxe.

Neste laboratório, você adicionará linting ao seu repositório que verifica automaticamente esses erros sempre que um desenvolvedor cria um pull request ou sempre que uma branch é mesclada na branch principal padrão. Antes de mergulharmos no laboratório, aqui está uma introdução sobre as Ações do GitHub.

Ações do GitHub
As ações do GitHub fornecem uma maneira orientada a eventos para automatizar tarefas em seu projeto. Existem vários tipos de eventos que você pode ouvir. Aqui estão alguns exemplos:

push: Executa tarefas quando alguém faz um push para um branch do repositório.
pull_request: Executa tarefas quando alguém cria um pull request (PR). Você também pode iniciar tarefas quando certas atividades acontecem, como:
PR aberto
PR fechado
PR reaberto
create: Executa tarefas quando alguém cria um branch ou uma tag.
delete: Executa tarefas quando alguém exclui um branch ou uma tag.
manually: Os trabalhos são iniciados manualmente.
Componentes do GitHub Action
Você usará um ou mais dos seguintes componentes neste laboratório:

Workflows: Uma coleção de jobs que você pode adicionar ao seu repositório.
Events: Uma atividade que inicia um workflow.
Jobs: Uma sequência de um ou mais passos. Jobs são executados em paralelo por padrão.
Steps: Tarefas individuais que podem ser executadas em um job. Um passo pode ser uma ação ou um comando.
Actions: O menor bloco de um workflow.
Fluxo de Trabalho do GitHub
Você recebe um modelo de fluxo de trabalho abaixo. Vamos examiná-lo.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
name: 'Lint Code'
on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]
jobs:
  lint_python:
    name: Lint Python Files
    runs-on: ubuntu-latest
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: 3.12
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8
    - name: Print working directory
      run: pwd
    - name: Run Linter
      run: |
        pwd
        # This command finds all Python files recursively and runs flake8 on them
        find . -name "*.py" -exec flake8 {} +
        echo "Linted all the python files successfully"
  lint_js:
      name: Lint JavaScript Files
      runs-on: ubuntu-latest
      steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
      - name: Install Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 14
      - name: Install JSHint
        run: npm install jshint --global
      - name: Run Linter
        run: |
          # This command finds all JavaScript files recursively and runs JSHint on them
          find ./server/database -name "*.js" -exec jshint {} +
          echo "Linted all the js files successfully"
Copied!
A primeira linha nomeia o fluxo de trabalho.
A próxima linha define quando este fluxo de trabalho será executado. O fluxo de trabalho deve ser executado quando os desenvolvedores fizerem um push de uma alteração para o branch principal ou criarem um PR. Essas duas maneiras são capturadas da seguinte forma:
executar no push para o branch principal (main ou master):
1
2
push:
  branches: [master, main]
Copied!
executar quando o PR é criado nos branches principais (main ou master):
1
2
pull_request:
  branches: [master, main]
Copied!
Você então definirá todos os trabalhos. Existem dois trabalhos neste fluxo de trabalho:
lint_python: Linting da função JavaScript
lint_js: Linting da função Python
GitHub Jobs
Vamos olhar para cada um desses trabalhos:

lint_python

Configure o ambiente Python para a ação rodar usando a actions/setup-python@v4.
Instale todas as dependências usando pip install.
Execute o comando de linting flake8 *.py em todos os arquivos no diretório do servidor recursivamente.
Imprima uma mensagem dizendo que o linting foi concluído com sucesso.
lint_function_js

Configure o ambiente Node.js para a ação rodar usando a actions/setup-node@v3.
Instale o linter JSHint npm install jshint.
Execute o comando de linting em todos os arquivos .js no diretório do banco de dados recursivamente.
Imprima uma mensagem dizendo que o linting foi concluído com sucesso.
Habilitar GitHub Actions
Para habilitar a ação do GitHub, faça login no GitHub e abra seu repositório forked. Em seguida, vá para a aba Actions e clique em Set up a workflow yourself.

Cole o código de lint fornecido acima dentro de main.yml e faça o commit.

Abra a aba Actions novamente, e você verá que o commit iniciou automaticamente o fluxo de trabalho de lint.

Você pode clicar na execução do fluxo de trabalho para ver os trabalhos individuais e os logs de cada trabalho. Quando o fluxo de trabalho for concluído com sucesso, você verá o sinal verde indicando que tudo correu bem. Uma cruz vermelha significaria que foram encontrados erros no código durante o linting.


5. Confira estas dicas para resolver erros de Linting comuns que você pode encontrar.
Clique aqui
